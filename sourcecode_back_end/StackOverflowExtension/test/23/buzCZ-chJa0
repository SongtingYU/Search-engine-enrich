Persisting data with Entity Framework code first

In practice, this is nothing more than a class that extends the Entity Framework DbContext base class, and provides any number of properties describing the entities that you will be persisting to the database. So we'll begin by creating one of these DbContext classes in our models folder. We'll name it AuctionsDataContext. Then we'll have it derived from the System.Data.Entity.DbContext class.

Now we'll tell Entity Framework about the properties that we'd like to persist to the database by exposing them in the form of properties on the data context that use the generic DbSet datatype. For example, we'll want to save auctions to our database, so we'll add an auctions property to our data context like this. And it's as simple as that. Now we can begin using our database context to interact with the database. To show the context in action let's overhaul our Auctions controller that has been littered with hard-coded auctions up to this point.

We'll replace those hard-coded auctions with references to our new data context like this one that saves a new auction to the database. Here I'm creating a new instance of the AuctionsDataContext, then I'm adding my instance of an auction to the Auctions collection in that data context. Finally, I'm calling the SaveChanges method to save those changes to the database. Before we're ready to run this code there is one more thing I have to do.

Depending on your system's configuration the site may or may not execute as we currently have it. This is because Entity Framework is pretty smart, and it tries to find the best way to create and access a database depending on the software that you have installed on your machine. To avoid this, we'll explicitly tell Entity Framework to use the technology called SQL Express LocalDB that was installed as part of Visual Studio. And will do this by adding a connection string to our Web.Config. To begin, open up your Web.Config file and find the connectionStrings section.

There were already be a connection string here that Visual Studio added for us, which tells Entity Framework where to find our membership database. This is just what we want to do for our database as well. So go ahead and make a copy of this connection string. Then replace any references to the ASP.NET membership database with a new database name. I'm using MvcAuction.Models.AuctionsDataContext the name of our data context. Likewise change the name of the connection string to MvcAuction.Models.AuctionsDataContext.

This name is very important because it matches the full class name of our data context, a convention that Entity Framework uses to locate the appropriate connection string for each data context. Finally, remove the initial catalog property, we're not going to be needing it. With this code in place go ahead and visit the Create page and try to add a new auction. By default, when you first attempt to read from or write to a DbContext Entity Framework will examine the model you've provided and automatically generate a database schema based on that model.

Entity Framework will also check to make sure that the database exists, and if it doesn't, Entity Framework will go ahead and create it for you. In order to do all this, however, Entity Framework requires a few things, most notably it requires a property that will serve as the Entity's primary key. Luckily, Entity Framework offers conventions that make this easy just make sure the entity you're trying to save has a property name Id or use the Key Data Annotation attribute to specify another property that will serve as the primary key.

Luckily, our auction model already has this property, so we don't need to add the Data Annotation. Note that before it saves anything to the database, Entity Framework guards against invalid data by using the data annotations that we applied in the previous video to validate the model. If it finds any properties with invalid values Entity Framework will refuse to save the entity and throw an exception instead. If you're able to post your auction without raising any exceptions, you can assume that your auction has been saved to the database.

The problem is we don't currently have any way of knowing for sure since our index action is still displaying a list of hard-coded auctions. So let's go ahead and take care of that right now. We'll start by removing the hard-coded auctions, and then we'll retrieve the auctions from the database instead. Notice how I'm calling the ToArray method on the Auctions property.